<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="PRG_INJ" Id="{8b858f89-a705-4da6-a8c0-4cd0b412d38f}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM PRG_INJ
VAR
	{attribute 'pytmc' :=' pv: AT1K0:GAS:CNTRL:SP;
	field: HOPR 1000;
	field: LOPR 0;
	field: PREC 2;
	field: EGU "TORR";
	'}
	fSetpointValue :REAL; 
	{attribute 'pytmc' :=' pv: AT1K0:GAS:CNTRL:GO;
	 field: ZNAM STOP; 
	 field: ONAM START; 
	 io: io;
	'}
	bGo: BOOL:=FALSE; 
 	{attribute 'pytmc' :=' pv: AT1K0:GAS:CNTRL:RESET;
	 field: ZNAM FALSE; 
	 field: ONAM TRUE; 
	 io: io;
	 '}
	bReset : BOOL; 
	{attribute 'pytmc' :=' pv: AT1K0:GAS:CNTRL:ERROR;
    field: ZNAM FALSE; 
	 field: ONAM TRUE; 
	 io: io;
	 '}
	bError : BOOL; 
	// different gains for different apertures
	{attribute 'pytmc' :=' pv: AT1K0:GAS:CNTRL:Kp1 '}
	fKp1 : REAL:= 0.3; 
	{attribute 'pytmc' :=' pv: AT1K0:GAS:CNTRL:Kp2 '}
	fKp2 : REAL:= 0.5; 
	{attribute 'pytmc' :=' pv: AT1K0:GAS:CNTRL:Kp3 '}
	fKp3 : REAL:= 0.6; 
	{attribute 'pytmc' :=' pv: AT1K0:GAS:CNTRL:Kp4 '}
	fKp4 : REAL:= 1.0; 
	{attribute 'pytmc' :=' pv: AT1K0:GAS:CNTRL:Tn1 '}
	fTn1 : REAL:= 0.5; 
	{attribute 'pytmc' :=' pv: AT1K0:GAS:CNTRL:Tn2 '}
	fTn2 : REAL:= 0.5; 
	arrTable	: ARRAY[1..15,1..2] OF FLOAT;
	fManValue											: FLOAT;
	bExtrapolate										: BOOL;
	eMode							: E_CTRL_MODE;
	stCTRL_PID_PARAMS		: ST_CTRL_PID_PARAMS;
	bSync							: BOOL;
	bHold							: BOOL;
	eErrorId						: E_CTRL_ERRORCODES;
	bARWactive					: BOOL;
	(* controller *)
	fbCTRL_PID					: FB_CTRL_PID;
	bInit							: BOOL	:= TRUE;
	fbCTRL_LIN_INTERPOLATION					: FB_CTRL_LIN_INTERPOLATION;
	//stCTRL_LIN_INTERPOLATION_PARAMS		: ST_CTRL_LIN_INTERPOLATION_PARAMS;
	stCTRL_LIN_INTERPOLATION_PARAMS	: ST_CTRL_LIN_INTERPOLATION_PARAMS;
	fbCTRL_DEADBAND						: FB_CTRL_DEADBAND;
	stCTRL_DEADBAND_PARAMS			: ST_CTRL_DEADBAND_PARAMS;

	pid_on :TON;
	wait : time := T#10S;
	FTrig: F_TRIG;
	fTrig_PMPS: F_TRIG;
	rTrig_PMPS: R_TRIG;	
	
	rtAction : R_TRIG;
	rtTrans: R_TRIG;

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Devices
// Valves
VCN_70(i_xExtIlkOK := (US_MAA_OK AND US_Turbo_Valves_Open AND US_Turbo_Running)
						AND (DS_MAA_OK AND DS_Turbo_Valves_Open AND DS_Turbo_Running), 
						i_ReqPos:= LREAL_TO_REAL(fbCTRL_LIN_INTERPOLATION.fOut + fbCTRL_PID.fOut));

VVC_71(i_xExtILK_OK:= VVC_72.M_IsClosed() AND ((US_MAA_OK AND (*US_Roughing_Valves_Open AND*) US_Turbo_Valves_Open AND US_Turbo_Running) 
						AND (DS_MAA_OK AND (*DS_Roughing_Valves_Open AND*) DS_Turbo_Valves_Open AND DS_Turbo_Running)), i_xOverrideMode:= , iq_stValve=> );
VVC_72(i_xExtILK_OK:= VVC_71.M_IsClosed() AND ((US_MAA_OK AND (*US_Roughing_Valves_Open AND *)US_Turbo_Valves_Open AND US_Turbo_Running) 
						AND (DS_MAA_OK AND (*DS_Roughing_Valves_Open AND *)DS_Turbo_Valves_Open AND DS_Turbo_Running)), i_xOverrideMode:= , iq_stValve=> );

//Gauges
GCM_70.M_SetBits(30518);
GCM_80.M_SetBits(30518);
GCM_81.M_SetBits(30518);
GCM_70(PG=> , i_rFULL_SCALE:= 2000);
GCM_80(PG=> , i_rFULL_SCALE:= 20);
GCM_81(PG=> , i_rFULL_SCALE:= 0.25);


(*Automation of other devices*)
(*When to Open the VRC Valves to the MAA chambers*)
(*When PID is ON*)
IF (bGo) THEN
	(*VRC US*)
	IF ( fb_AT1K0_GAS_GPI_40.PG .rPRESS >= rVRC_US_SP ) THEN
		IF (fb_AT1K0_GAS_VRC_50.M_IsOpen()) THEN fb_AT1K0_GAS_VRC_60.M_Set_OPN_SW (TRUE);
			ELSE fb_AT1K0_GAS_VRC_50.M_Set_OPN_SW (TRUE);
		END_IF
	END_IF
	
	(*VRC DS*)
	IF ( fb_AT1K0_GAS_GPI_110.PG .rPRESS >= rVRC_DS_SP ) THEN
		IF (fb_AT1K0_GAS_VRC_100.M_IsOpen()) THEN fb_AT1K0_GAS_VRC_90.M_Set_OPN_SW (TRUE);
			ELSE fb_AT1K0_GAS_VRC_100.M_Set_OPN_SW (TRUE);
		END_IF
	END_IF
	ELSE
		//Try to switch on the GCC in the Gas cell for accurate transmission calculation
		IF  NOT(fb_AT1K0_GAS_GCC_80.IG.i_xHV_ON) THEN fb_AT1K0_GAS_GCC_80.M_HVE(TRUE); END_IF;
END_IF

(*Gas Selection*)
IF(VVC_71.M_IsOpen()) THEN  SelectedGas := E_GasType.Argon;
	ELSIF (VVC_72.M_IsOpen()) THEN  SelectedGas := E_GasType.Nitrogen;
END_IF

(* Gauge selection *)
(*Assign reading to psuedo gauge*)
IF (fb_AT1K0_GAS_GCC_80.IG.rPRESS <=0.0001) AND (fb_AT1K0_GAS_GCC_80.IG.rPRESS >0) THEN GCM_82 := fb_AT1K0_GAS_GCC_80.IG;
	ELSIF (fb_AT1K0_GAS_GPI_80.PG.rPRESS <= 0.001) AND (fb_AT1K0_GAS_GPI_80.PG.rPRESS > 0.0001) THEN GCM_82 := fb_AT1K0_GAS_GPI_80.PG;
		ELSIF ( GCM_81.PG.rPRESS < 0.25 ) THEN GCM_82 := GCM_81.PG;
			ElSE GCM_82 := GCM_80.PG;
END_IF

(* Gain selection *)
CASE eSelectedAprt OF
	E_MAA_States.Aprt1:
		stCTRL_PID_PARAMS.fKp					:= fKp1;
	E_MAA_States.Aprt2:
		stCTRL_PID_PARAMS.fKp					:= fKp2;
	E_MAA_States.Aprt3:
		stCTRL_PID_PARAMS.fKp					:= fKp3;
	E_MAA_States.Aprt4:
		stCTRL_PID_PARAMS.fKp					:= fKp4;	
END_CASE
	


(* On change transmission reset *)
IF( OldTransmissionValue <> TransmissionValue) THEN
	OldTransmissionValue := TransmissionValue;
	// change setpoint
	// As calculated by the PRG_INJ
	fSetpointValue := rRequiredPressureSP;
	fbLogger(sMsg:='AT1K0 new transmission request.', eSevr:=TcEventSeverity.Info);
END_IF
(*Setpoint Validation*)
fSetpointValue:= LIMIT(0,fSetpointValue,10);
	
(*Interlock setpoint reset*)
if (VVC_71.M_IsClosed() AND VVC_72.M_IsClosed() ) THEN 
		//eMode	:= eCTRL_MODE_PASSIVE;
		fSetpointValue :=0; 
END_IF 

if (bGo) THEN
	IF (bReset) THEN
	(* set the mode to RESET*)
	eMode							:= eCTRL_MODE_RESET   ;
	VCN_70.M_ValveControl(CloseValve);
	//bReset := False;
	ELSE
		(* set the mode to ACTIVE --> normal operation *)
	eMode							:= eCTRL_MODE_ACTIVE   ;
 	VCN_70.M_ValveControl(PressureControl);
	END_IF
END_IF
FTRIG(CLK := bGo);
IF(FTrig.Q)THEN
		eMode							:= eCTRL_MODE_PASSIVE;
		VCN_70.M_ValveControl(CloseValve);
		fSetpointValue :=0;
END_IF


fbCTRL_LIN_INTERPOLATION(
	fIn:= fSetpointValue , 
	fManValue:= fManValue , 
	bExtrapolate:= bExtrapolate, 
	eMode:= eMode, 
	stParams:= stCTRL_LIN_INTERPOLATION_PARAMS,
	fOut=> , 
	bInIsGreaterThanMaxElement=> , 
	bInIsLessThanMinElement=> , 
	eState=> , 
	eErrorId=> , 
	bError=> );


(* call controller *)
fbCTRL_PID(		fSetpointValue		:= fSetpointValue,
					fActualValue		:= GCM_82.rPRESS ,
					fManSyncValue	:= ,
					bSync				:= bSync,
					eMode				:= eMode,
					bHold				:= bHold,
					stParams			:= stCTRL_PID_PARAMS,
					fOut				=> ,
					bARWactive		=> bARWactive,
					eErrorId			=> eErrorId,
					bError				=> 
				);

	
(*deadband/clipper *)

(* call function block *)
stCTRL_DEADBAND_PARAMS.fThreshold	:=  fSetpointValue*0.0016 ;
(*fbCTRL_DEADBAND	(	fIn					:= ,
					stParams			:= stCTRL_DEADBAND_PARAMS,
					bInIsUnderThreshold => ,
					eErrorId			=> ,
					bError				=> 
				);*)

bError := fbCTRL_PID.bError OR fbCTRL_LIN_INTERPOLATION.bError;
				
// Turn the PID on rising edge of the PMPSMode and off at falling edge
fTrig_PMPS(CLK:= xPMPSMode);
rTrig_PMPS(CLK:= xPMPSMode);
IF (xPMPSMode) THEN bGo := TRUE; END_IF	
IF (fTrig_PMPS.Q) THEN bGo := FALSE; END_IF
//IF (rTrig_PMPS.Q) THEN bGo := TRUE; END_IF

ACT_Logger();]]></ST>
    </Implementation>
    <Action Name="ACT_Init" Id="{34882f0d-6946-4b6d-ab99-e24f4514a23d}">
      <Implementation>
        <ST><![CDATA[//control Loop and FeedForward table initialisation
(*Iniitialization*)
IF bInit
THEN
	(* init array with the interpolation points  *)
	(* 	fIn					 |		fOut		*)
	arrTable[1,1] := 0;		    arrTable[1,2] := 12;
	arrTable[2,1] := 0.00001;	arrTable[2,2] := 18;
	arrTable[3,1] := 0.001024;	arrTable[3,2] := 30;
	arrTable[4,1] :=  0.021;	arrTable[4,2] := 40;
	arrTable[5,1] :=  0.1;	    arrTable[5,2] := 50;
	arrTable[6,1] := 0.8;		arrTable[6,2] := 60;
	arrTable[7,1] := 1.5;		arrTable[7,2] := 64;
	arrTable[8,1] := 2;		    arrTable[8,2] := 66;
	arrTable[9,1] := 2.9;		arrTable[9,2] := 68;
	arrTable[10,1] := 5.4;		arrTable[10,2] := 77;
	arrTable[11,1] := 6.9;	    arrTable[11,2] := 78;
	arrTable[12,1] :=9;	    arrTable[12,2] := 80;
	arrTable[13,1] :=9.85;	    arrTable[13,2] := 82;
	arrTable[14,1] :=9.9;	    arrTable[14,2] := 84;
	arrTable[15,1] :=10;	    arrTable[15,2] := 86;

	(* init parameter struct *)
	stCTRL_LIN_INTERPOLATION_PARAMS.tCtrlCycleTime					:= T#10ms;
	stCTRL_LIN_INTERPOLATION_PARAMS.tTaskCycleTime					:= T#10ms;
	stCTRL_LIN_INTERPOLATION_PARAMS.nDataTable_NumberOfRows		:= INT_TO_UINT(15);	

	(*FBCNTRL*)
	(* init parameter struct *)
	stCTRL_PID_PARAMS.tCtrlCycleTime		:= T#10ms;
	stCTRL_PID_PARAMS.tTaskCycleTime		:= T#10ms;
	stCTRL_PID_PARAMS.fKp					:= fKp1;			(* proportional gain Kp				*)
	stCTRL_PID_PARAMS.tTn					:= T#500ms;		(*  Tn									*)
	stCTRL_PID_PARAMS.tTv					:= T#200ms;	(*  Tv									*)
	stCTRL_PID_PARAMS.tTd					:= T#100ms;	(*  Td									*)
	stCTRL_PID_PARAMS.fOutMaxLimit			:=  20;			(* maximum output limit				*)
	stCTRL_PID_PARAMS.fOutMinLimit			:=  -100;			(* minimum output limit				*)

	(* set the mode to ACTIVE --> normal operation *)
	eMode							:= eCTRL_MODE_PASSIVE   ;					
	(* reset the init flag *)
	bInit							:= FALSE;
END_IF
(* set the addresses *)
	stCTRL_LIN_INTERPOLATION_PARAMS.pDataTable_ADR			:= ADR(arrTable);
	stCTRL_LIN_INTERPOLATION_PARAMS.nDataTable_SIZEOF	:= SIZEOF(arrTable);]]></ST>
      </Implementation>
    </Action>
    <Action Name="ACT_Logger" Id="{f54af55b-dc6e-4d67-a7ae-15da10ebcc66}">
      <Implementation>
        <ST><![CDATA[rtAction(CLK:=eSelectedAprt <>  eSetAprt);

IF (fTrig_PMPS.Q) THEN fbLogger(sMsg:='AT1K0 switched to local mode.', eSevr:=TcEventSeverity.Info);  END_IF
IF (rTrig_PMPS.Q) THEN fbLogger(sMsg:='AT1K0 switched to PMPS mode.', eSevr:=TcEventSeverity.Info);   END_IF

IF (rtAction.Q) THEN  fbLogger(sMsg:='AT1K0-MAA current aperture size mismatch', eSevr:=TcEventSeverity.Critical);   END_IF]]></ST>
      </Implementation>
    </Action>
  </POU>
</TcPlcObject>